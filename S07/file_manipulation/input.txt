ANSI escape code
From Wikipedia, the free encyclopedia
Jump to navigation
Jump to search
"ANSI code" redirects here. For other uses, see ANSI (disambiguation).

This article has multiple issues. Please help improve it or discuss these issues on the talk page. (Learn how and when to remove these template messages)
This article needs additional citations for verification. (January 2017)
This article may be too technical for most readers to understand. Please help improve it to make it understandable to non-experts, without removing the technical details. (June 2016)

ANSI escape sequences are a standard for in-band signaling to control the cursor location, color, and other options on video text terminals and terminal emulators. Certain sequences of bytes, most starting with Esc and '[', are embedded into the text, which the terminal looks for and interprets as commands, not as character codes.

ANSI sequences were introduced in the 1970s to replace vendor-specific sequences and became widespread in the computer equipment market by the early 1980s. They were used in development, scientific and commercial applications and later by the nascent bulletin board systems to offer improved displays compared to earlier systems lacking cursor movement, a primary reason they became a standard adopted by all manufacturers.

Although hardware text terminals have become increasingly rare in the 21st century, the relevance of the ANSI standard persists because most terminal emulators interpret at least some of the ANSI escape sequences in output text. A notable exception was DOS and older versions of the Win32 console of Microsoft Windows.
Contents

    1 History
    2 Platform support
        2.1 Unix-like systems
        2.2 DOS
        2.3 OS/2
        2.4 Atari ST
        2.5 AmigaOS
        2.6 Windows
    3 Escape sequences
    4 CSI sequences
    5 SGR parameters
    6 Colors
        6.1 3/4 bit
        6.2 8-bit
        6.3 24-bit
    7 Examples
        7.1 Example of use in shell scripting
    8 Invalid and ambiguous sequences in use
    9 See also
    10 Notes
    11 References
    12 External links

History

Almost all manufacturers of video terminals added vendor-specific escape sequences to perform operations such as placing the cursor at arbitrary positions on the screen. One example is the VT52 terminal, which allowed the cursor to be placed at an x,y location on the screen by sending the ESC character, a Y character, and then two characters representing with numerical values equal to the x,y location plus 32 (thus starting at the ASCII space character and avoiding the control characters).

As these sequences were different for different terminals, elaborate libraries such as termcap and utilities such as tput had to be created so programs could use the same API to work with any terminal. In addition many of these terminals required sending numbers (such as row and column) as the binary values of the characters; for some programming languages, and for systems that did not use ASCII internally, it was often difficult or impossible to turn a number into the correct character.

The ANSI standard attempted to address these problems by making a command set that all terminals would use and requiring all numeric information to be transmitted as ASCII numbers. The first standard in the series was ECMA-48, adopted in 1976. It was a continuation of a series of character coding standards, the first one being ECMA-6 from 1965, a 7-bit standard from which ISO 646 originates. The name "ANSI escape sequence" dates from 1979 when ANSI adopted ANSI X3.64. The ANSI X3L2 committee collaborated with the ECMA committee TC 1 to produce nearly identical standards. These two standards were merged into an international standard, ISO 6429.[1] In 1994, ANSI withdrew its standard in favor of the international standard.

The first popular video terminal to support these sequences was the Digital VT100, introduced in 1978.[2] This model was very successful in the market, which sparked a variety of VT100 clones, among the earliest and most popular of which was the much more affordable Zenith Z-19 in 1979.[3] Others included the Qume QVT-108, Televideo TVI-970, Wyse WY-99GT as well as optional "VT100" or "VT103" or "ANSI" modes with varying degrees of compatibility on many other brands. The popularity of these gradually led to more and more software (especially bulletin board systems and other online services) assuming the escape sequences worked, leading to almost all new terminals and emulator programs supporting them.

In 1981, ANSI X3.64 was adopted for use in the US government by FIPS publication 86. Later, the US government stopped duplicating industry standards, so FIPS pub. 86 was withdrawn.[4]

ECMA-48 has been updated several times and is currently at its 5th edition, from 1991. It is also adopted by ISO and IEC as standard ISO/IEC 6429.
Platform support
Unix-like systems

Although termcap/terminfo-style libraries were primarily developed on and for Unix, since about 1984 programs running on Unix-like operating systems could almost always assume they were using a terminal or emulator that supported ANSI sequences;[citation needed] this led to widespread use of ANSI by programs running on those platforms. For instance, many games and shell scripts (see below for colored prompt examples), and utilities such as color directory listings, directly write the ANSI sequences and thus cannot be used on a terminal that does not interpret them. Many programs, including text editors such as vi and GNU Emacs, still use termcap or terminfo, or use libraries such as curses that use termcap or terminfo, and thus in theory support non-ANSI terminals, but this is so rarely tested nowadays that they are unlikely to work with those terminals.[citation needed] Terminal emulators for communicating with local programs as well as remote machines and the text system console almost always support ANSI escape codes.
DOS

MS-DOS 1.x did not support the ANSI or any other escape sequences. Only a few control characters (BEL, CR, LF, BS) were interpreted by the underlying BIOS, making it almost[nb 1] impossible to do any kind of full-screen application. Any display effects had to be done with BIOS calls, which were notoriously slow, or by directly manipulating the IBM PC hardware.

DOS 2.0 introduced the ability to add a device driver for the ANSI escape sequences – the de facto standard being ANSI.SYS, but others like ANSI.COM,[5] NANSI.SYS[6] and ANSIPLUS.EXE are used as well (these are considerably faster as they bypass the BIOS). Slowness and the fact that it was not installed by default made software rarely take advantage of it; instead, applications continued to directly manipulate the hardware to get the text display needed.[citation needed] ANSI.SYS and similar drivers continued to work in Windows 9x up to Windows Me, and in NT-derived systems for 16-bit legacy programs executing under the NTVDM.

PTS-DOS[7][8] as well as Concurrent DOS, Multiuser DOS[9] and REAL/32 have built-in support for ANSI ecape sequences (plus a number of extensions) and do not require a separate ANSI driver to be loaded.
OS/2

The ANSI command in a batch file or at the command line enables the extensions.
Atari ST

The Atari ST used the command system adapted from the VT52 with some expansions for color support,[10] rather than supporting ANSI escape codes.
AmigaOS

AmigaOS not only interprets ANSI code sequences for text output to the screen, the AmigaOS printer driver also interprets them (with extensions proprietary to AmigaOS) and translates them into the codes required for the particular printer that is actually attached.[11]
Windows

The Win32 console did not originally support ANSI escape sequences. Some replacements or additions for the console window such as JP Software's TCC (formerly 4NT), Michael J. Mefford's ANSI.COM, Jason Hood's ANSICON[12] and Maximus5's ConEmu interpreted ANSI escape sequences printed by programs. A Python package[13] internally interpreted ANSI escape sequences in text being printed, translating them to calls to manipulate the color and cursor position, to make it easier to port Python code using ANSI to Windows.

In 2016, Microsoft released the Windows 10 Version 1511 update which unexpectedly implemented support for ANSI escape sequences[14]. The change was designed to complement the Windows Subsystem for Linux, adding to the Windows Console Host used by Command Prompt support for character escape codes used by terminal-based software for Unix-like systems. This is not the default behavior and must be enabled by enabled programmatically with the Win32 API via SetConsoleMode(handle, ENABLE_VIRTUAL_TERMINAL_PROCESSING).[15] This was enabled by CMD.EXE but not initially by PowerShell[16] however, Windows PowerShell 5.1 now enables this by default. The ability to make a string constant containing ESC was added in PowerShell 6 with (for example) "`e[32m",[17] for PowerShell 5 you had to use [char]0x1B+"[32m".
Escape sequences

Sequences have different lengths. All sequences start with ESC (27 / hex 0x1B), followed by a second byte in the range 0x40–0x5F (ASCII @A–Z[\]^_).[18]:5.3.a

The standard says that in 8-bit environments these two-byte sequences can be merged into single C1 control code in the 0x80–0x9F range.[18]:5.4.a However on modern devices those codes are often used for other purposes, such as parts of UTF-8 or for CP-1252 characters, so only the 2-byte sequence is used.

Other C0 codes besides ESC — commonly BEL, BS, CR, LF, FF, TAB, VT, SO, and SI — produce similar or identical effects to some control sequences when output.
Some ANSI escape sequences (not an exhaustive list) Sequence 	C1 	Name 	Effect
ESC N 	0x8E 	SS2 – Single Shift Two 	Select a single character from one of the alternative character sets. In xterm, SS2 selects the G2 character set, and SS3 selects the G3 character set.[19]
ESC O 	0x8F 	SS3 – Single Shift Three
ESC P 	0x90 	DCS – Device Control String 	Terminated by ST. Xterm's uses of this sequence include defining User-Defined Keys, and requesting or setting Termcap/Terminfo data.[19]
ESC [ 	0x9B 	CSI - Control Sequence Introducer 	Most of the useful sequences, see next section.
ESC \ 	0x9C 	ST – String Terminator 	Terminates strings in other controls.[18]:8.3.143
ESC ] 	0x9D 	OSC – Operating System Command 	Starts a control string for the operating system to use, terminated by ST.[18]:8.3.89 In xterm, they may also be terminated by BEL.[19] In xterm, the window title can be set by OSC 0;this is the window title BEL.
ESC X 	0x98 	SOS – Start of String 	Takes an argument of a string of text, terminated by ST. The uses for these string control sequences are defined by the application[18]:8.3.2,8.3.128 or privacy discipline.[18]:8.3.94 These functions are not implemented and the arguments are ignored by xterm.[19]
ESC ^ 	0x9E 	PM – Privacy Message
ESC _ 	0x9F 	APC – Application Program Command
ESC c 		RIS – Reset to Initial State 	Resets the device to its original state. This may include (if applicable): reset graphic rendition, clear tabulation stops, reset to default font, and more.

Pressing special keys on the keyboard, as well as outputting many xterm CSI, DCS, or OSC sequences, often produces a CSI, DCS, or OSC sequence, sent from the terminal to the computer as though the user typed it.

CSI sequences

For CSI, or "Control Sequence Introducer" commands, the ESC [ is followed by any number (including none) of "parameter bytes" in the range 0x30–0x3F (ASCII 0–9:;<=>?), then by any number of "intermediate bytes" in the range 0x20–0x2F (ASCII space and !"#$%&'()*+,-./), then finally by a single "final byte" in the range 0x40–0x7E (ASCII @A–Z[\]^_`a–z{|}~).[18]:5.4

All common sequences just use the parameters as a series of semicolon-separated numbers such as 1;2;3. Missing numbers are treated as 0 (1;;3 acts like the middle number is 0, and no parameters at all in ESC[m acts like a 0 reset code). Some sequences (such as CUU) treat 0 as 1 in order to make missing parameters useful.[18]:F.4.2 Bytes other than digits and semicolon seem to not be used.[citation needed]

A subset of arrangements was declared "private" so that terminal manufacturers could insert their own sequences without conflicting with the standard. Sequences containing the parameter bytes <=>? or the final bytes 0x70–0x7E (p–z{|}~) are private.

The behavior of the terminal is undefined in the case where a CSI sequence contains any character outside of the range 0x20–0x7E. These illegal characters are either C0 control characters (the range 0–0x1F), DEL (0x7F), or bytes with the high bit set. Possible responses are to ignore the byte, to process it immediately, and furthermore whether to continue with the CSI sequence, to abort it immediately, or to ignore the rest of it.[citation needed]